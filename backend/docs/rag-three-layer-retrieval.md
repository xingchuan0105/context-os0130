# RAG 三层检索策略设计

## 概述

本文档定义了 Context OS 的 RAG 检索策略：**由粗到精的三层钻取检索**。

## 检索流程

```
用户问题 → 问题理解 → 文档级检索 → 父块级检索 → 子块级检索 → 组装上下文
```

### 流程详解

```
┌─────────────────────────────────────────────────────────────────┐
│                     用户问题: "如何配置 API 密钥?"                │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│                    步骤1: 问题理解                               │
│  - LLM 分析问题类型（Procedure 问题）                            │
│  - 提取关键词：API 密钥、配置                                    │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌──────���──────────────────────────────────────────────────────────┐
│                    步骤2: 文档级检索                             │
│  - 在 K-Type 摘要中搜索 "API 密钥配置"                           │
│  - 找到相关文档：[API 集成指南]                                  │
│  - 获取文档摘要：本文档涵盖 API 密钥配置、权限管理...             │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│                    步骤3: 父块级检索                             │
│  - 在该文档的父块中搜索                                         │
│  - 找到相关父块：[配置 API 密钥完整流程]                         │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│                    步骤4: 子块级检索                             │
│  - 在父块的子块中搜索                                           │
│  - 找到相关子块：[步骤1：登录控制台...] [步骤2：新建密钥...]     │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│                    步骤5: 组装上下文                             │
│  给 LLM 的完整上下文：                                           │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ 【文档摘要】                                              │    │
│  │ 本文档以 Procedure 为主，核心模块：API 密钥配置...         │    │
│  │                                                          │    │
│  │ 【父块上下文】                                            │    │
│  │ 配置 API 密钥是第一步，每个账户可创建 5 个密钥...          │    │
│  │                                                          │    │
│  │ 【相关步骤】                                              │    │
│  │ 步骤1：登录控制台...                                      │    │
│  │ 步骤2：点击"新建密钥"...                                  │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

## Qdrant 三层向量索引

### 层级定义

| 层级 | 内容 | 向量用途 | 过滤条件 |
|-----|------|---------|---------|
| **文档层** | K-Type 摘要 | 找到相关文档 | `type='document'` |
| **父块层** | 父块内容 | 找到相关章节 | `type='parent'`, `doc_id=xxx` |
| **子块层** | 子块内容 | 找到具体内容 | `type='child'`, `parent_id=xxx` |

### Qdrant 数据结构

```typescript
// 文档级向量点
{
  id: 1_000_000 + docId,
  vector: embedding(ktype_summary),
  payload: {
    type: 'document',
    doc_id: 'xxx',
    content: ktype_summary,
    metadata: { title: 'API 集成指南' }
  }
}

// 父块向量点
{
  id: parentId,
  vector: embedding(parent_content),
  payload: {
    type: 'parent',
    doc_id: 'xxx',
    content: parent_content,
    chunk_index: 0,
    metadata: {}
  }
}

// 子块向量点
{
  id: childId,
  vector: embedding(child_content),
  payload: {
    type: 'child',
    doc_id: 'xxx',
    parent_id: parentId,
    content: child_content,
    chunk_index: 0,
    metadata: {}
  }
}
```

### ID 分配策略

| 层级 | ID 范围 | 说明 |
|-----|---------|------|
| document | 1,000,000 - 1,999,999 | 文档级向量点 |
| parent | 1 - 999,999 | 父块向量点 |
| child | 1 - 999,999 | 子块向量点（与 parent 共用空间，通过 type 区分） |

**设计考虑**：
- 文档层使用高位 ID，便于区分和过滤
- parent 和 child 在同一 ID 空间，便于通过 parent_id 关联
- 每个文档的 parent 从 1 开始递增，child 从 1 开始递增

### 向量点数量估算

| 内容类型 | 数量估算 |
|---------|---------|
| 每个文档 | 1 个文档向量 |
| 每个文档 | ~20 个父块向量（假设） |
| 每个文档 | ~80 个子块向量（假设） |
| 每个文档总计 | ~101 个向量点 |
| 1000 个用户，每人 100 个文档 | ~10,100,000 个向量点 |

## 检索代码结构

```typescript
async function retrieveWithDrillDown(query: string, userId: string) {
  const queryVector = await embed(query)

  // 第一步：文档级检索
  const docResults = await qdrant.search(userId, queryVector, {
    filter: { type: 'document' },
    limit: 1  // 取最相关的 1 个文档
  })

  if (docResults.length === 0) {
    return null
  }

  const targetDocId = docResults[0].payload.doc_id

  // 第二步：在该文档的父块中检索
  const parentResults = await qdrant.search(userId, queryVector, {
    filter: {
      type: 'parent',
      doc_id: targetDocId
    },
    limit: 1  // 取最相关的 1 个父块
  })

  // 第三步：在该父块的子块中检索
  const childResults = await qdrant.search(userId, queryVector, {
    filter: {
      type: 'child',
      parent_id: parentResults[0]?.id
    },
    limit: 3  // 取前 3 个子块
  })

  // 组装上下文
  return {
    document: docResults[0],
    parent: parentResults[0],
    children: childResults
  }
}
```

## 优势

| 优势 | 解释 |
|-----|------|
| **精准定位** | 先找到对的文档，再找对的章节，最后找具体内容 |
| **上下文丰富** | 三层上下文递进，LLM 能理解完整脉络 |
| **避免噪声** | 不会在无关文档的子块中搜索，减少误召回 |
| **符合人类认知** | 就像查书：先找到书，再翻到章节，最后看段落 |

## K-Type 摘要的定义

K-Type 不是简单的分类标签，而是 **高密度的认知摘要**：

```
本文档以 Procedure(操作步骤)为主导(75%)，辅以 Theory(原理说明)(20%)。
核心知识模块：[安装配置、故障排查、API调用]。
认知价值：高实操性，适合工程师作为操作指南使用。
```

这种摘要：
- 保留丰富的语义信息
- 可用于文档级向量搜索
- 可作为 RAG 上下文提供给 LLM
